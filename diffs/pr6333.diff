diff --git a/python/cuml/cuml/internals/api_decorators.py b/python/cuml/cuml/internals/api_decorators.py
index f37ff7df97..55ce4407ca 100644
--- a/python/cuml/cuml/internals/api_decorators.py
+++ b/python/cuml/cuml/internals/api_decorators.py
@@ -55,16 +55,18 @@ def _find_arg(sig, arg_name, default_position):
 
     # Check for default name in input args
     if arg_name in sig.parameters:
-        return arg_name, params.index(arg_name)
+        param = sig.parameters[arg_name]
+        return arg_name, params.index(arg_name), param.default
     # Otherwise use argument in list by position
     elif arg_name is ...:
         index = int(_has_self(sig)) + default_position
-        return params[index], index
+        param = params[index]
+        return param, index, sig.parameters[param].default
     else:
         raise ValueError(f"Unable to find parameter '{arg_name}'.")
 
 
-def _get_value(args, kwargs, name, index):
+def _get_value(args, kwargs, name, index, default_value):
     """Determine value for a given set of args, kwargs, name and index."""
     try:
         return kwargs[name]
@@ -72,10 +74,13 @@ def _get_value(args, kwargs, name, index):
         try:
             return args[index]
         except IndexError:
-            raise IndexError(
-                f"Specified arg idx: {index}, and argument name: {name}, "
-                "were not found in args or kwargs."
-            )
+            if default_value is not inspect._empty:
+                return default_value
+            else:
+                raise IndexError(
+                    f"Specified arg idx: {index}, and argument name: {name}, "
+                    "were not found in args or kwargs."
+                )
 
 
 def _make_decorator_function(
@@ -166,7 +171,7 @@ def wrapper(*args, **kwargs):
                         if self_val is None:
                             assert input_val is not None
                             out_type = iu.determine_array_type(input_val)
-                        elif input_val is None:
+                        elif input_val is None or input_val is inspect._empty:
                             out_type = self_val.output_type
                             if out_type == "input":
                                 out_type = self_val._input_type
diff --git a/python/cuml/cuml/neighbors/nearest_neighbors.pyx b/python/cuml/cuml/neighbors/nearest_neighbors.pyx
index 09dbd8999b..dd5d192b6c 100644
--- a/python/cuml/cuml/neighbors/nearest_neighbors.pyx
+++ b/python/cuml/cuml/neighbors/nearest_neighbors.pyx
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2019-2024, NVIDIA CORPORATION.
+# Copyright (c) 2019-2025, NVIDIA CORPORATION.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -28,6 +28,7 @@ import math
 import cuml.internals
 from cuml.internals.base import UniversalBase
 from cuml.common.array_descriptor import CumlArrayDescriptor
+from cuml.internals import api_base_return_generic
 from cuml.internals.array import CumlArray
 from cuml.internals.array_sparse import SparseCumlArray
 from cuml.common.doc_utils import generate_docstring
@@ -691,6 +692,9 @@ class NearestNeighbors(UniversalBase,
             if out_type in {'cupy', 'numpy', 'numba'}:
                 I_ndarr = I_ndarr[:, 1:]
                 D_ndarr = D_ndarr[:, 1:]
+            elif out_type == "cuml":
+                I_ndarr = CumlArray.from_input(I_ndarr[:, 1:], force_contiguous=True)
+                D_ndarr = CumlArray.from_input(D_ndarr[:, 1:], force_contiguous=True)
             else:
                 I_ndarr.drop(I_ndarr.columns[0], axis=1)
                 D_ndarr.drop(D_ndarr.columns[0], axis=1)
diff --git a/python/cuml/cuml/tests/experimental/accel/test_basic_estimators.py b/python/cuml/cuml/tests/experimental/accel/test_basic_estimators.py
index d73165c119..6b1ec309a1 100644
--- a/python/cuml/cuml/tests/experimental/accel/test_basic_estimators.py
+++ b/python/cuml/cuml/tests/experimental/accel/test_basic_estimators.py
@@ -173,6 +173,18 @@ def test_proxy_facade():
             assert original_value == proxy_value
 
 
+def test_defaults_args_only_methods():
+    # Check that estimator methods that take no arguments work
+    # These are slightly weird because basically everything else takes
+    # a X as input.
+    X = np.random.rand(1000, 3)
+    y = X[:, 0] + np.sin(6 * np.pi * X[:, 1]) + 0.1 * np.random.randn(1000)
+
+    nn = NearestNeighbors(metric="chebyshev", n_neighbors=3)
+    nn.fit(X[:, 0].reshape((-1, 1)), y)
+    nn.kneighbors()
+
+
 def test_kernel_ridge():
     rng = np.random.RandomState(42)
 
